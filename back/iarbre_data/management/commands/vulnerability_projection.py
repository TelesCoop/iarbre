"""Vulnerabity projection

This command assigns vulnerability zones to tiles based on spatial intersection.
For each tile (5x5m squares), it finds the vulnerability zone with the largest
intersection area and assigns it as the foreign key relationship.
"""

from django.core.management.base import BaseCommand
from django.db import transaction
from tqdm import tqdm

from iarbre_data.models import Tile, Vulnerability
from iarbre_data.utils.database import log_progress

BATCH_SIZE = 10_000


class Command(BaseCommand):
    help = "Assign vulnerability zones to tiles based on spatial intersection."

    def add_arguments(self, parser):
        parser.add_argument(
            "--recompute",
            action="store_true",
            help="Recompute vulnerability assignments for all tiles",
        )

    def handle(self, *args, **options):
        """Assign vulnerability zones to tiles based on spatial intersection."""
        recompute = options["recompute"]

        log_progress("Starting vulnerability assignment process")

        # Get tiles that need vulnerability assignment
        if recompute:
            tiles_query = Tile.objects.all()
            log_progress("Processing all tiles (recompute all of them)")
        else:
            tiles_query = Tile.objects.filter(vulnerability_idx__isnull=True)
            log_progress("Processing tiles without vulnerability assignment")

        total_tiles = tiles_query.count()
        if total_tiles == 0:
            self.stdout.write(
                self.style.SUCCESS("No tiles need vulnerability assignment.")
            )
            return

        self.stdout.write(f"Processing {total_tiles} tiles...")

        updates = []
        with tqdm(total=total_tiles, desc="Processing tiles") as pbar:
        tile_ids = list(tiles_query.values_list("id", flat=True))
        with tqdm(total=len(tile_ids), desc="Processing tiles") as pbar:
            for start in range(0, len(tile_ids), BATCH_SIZE):
                end = start + BATCH_SIZE
                batch_ids = tile_ids[start:end]
                batch_tiles = Tile.objects.filter(id__in=batch_ids)

                for tile in batch_tiles:
                    vulnerability = self._find_best_vulnerability_for_tile(tile)
                    if vulnerability:
                        tile.vulnerability_idx = vulnerability
                        updates.append(tile)

                    pbar.update(1)

                if updates:
                    with transaction.atomic():
                        Tile.objects.bulk_update(
                            updates, ["vulnerability_idx"], batch_size=BATCH_SIZE
                        )
                    updates.clear()

        # Remaining tiles
        if updates:
            with transaction.atomic():
                Tile.objects.bulk_update(updates, ["vulnerability_idx"])
        # Report results
        assigned_count = Tile.objects.filter(vulnerability_idx__isnull=False).count()
        total_count = Tile.objects.count()

        log_progress("Vulnerability assignment completed")
        self.stdout.write(
            self.style.SUCCESS(
                f"Successfully assigned vulnerabilities to tiles. "
                f"{assigned_count}/{total_count} tiles now have vulnerability assignments."
            )
        )

    def _find_best_vulnerability_for_tile(self, tile: Tile) -> Vulnerability | None:
        """
        Find the vulnerability zone with the largest intersection area for a given tile.

        Args:
            tile (Tile): Tile object to find vulnerability for

        Returns:
            Vulnerability | None: Vulnerability object with largest intersection, or None if no intersection
        """
        # Find all vulnerabilities that intersect with the tile
        intersecting_vulnerabilities = Vulnerability.objects.filter(
            geometry__intersects=tile.geometry
        )

        if not intersecting_vulnerabilities.exists():
            return None

        best_vulnerability = None
        max_intersection_area = 0

        for vulnerability in intersecting_vulnerabilities:
            try:
                # Calculate intersection area
                intersection = tile.geometry.intersection(vulnerability.geometry)
                intersection_area = intersection.area

                if intersection_area > max_intersection_area:
                    max_intersection_area = intersection_area
                    best_vulnerability = vulnerability

            except Exception as e:
                # Log geometry errors but continue processing
                self.stdout.write(
                    self.style.WARNING(
                        f"Geometry error for tile {tile.id} and vulnerability {vulnerability.id}: {e}"
                    )
                )
                continue

        return best_vulnerability
