from django.core.management.base import BaseCommand
from django.db import close_old_connections
import mapbox_vector_tile
from tqdm import tqdm
import io
import gc
from concurrent.futures import ThreadPoolExecutor, as_completed

from iarbre_data.models import MVTTile, Tile
from api.constants import GeoLevel, DataType


class Command(BaseCommand):
    help = "Update existing MVT tiles with vulnerability data without full regeneration"

    def add_arguments(self, parser):
        parser.add_argument(
            "--number-of-threads",
            type=int,
            default=1,
            help="Number of threads to use for parallel processing (default: 1)",
        )

    def handle(self, *args, **options):
        number_of_threads = options["number_of_threads"]

        mvt_tiles = list(
            MVTTile.objects.filter(
                geolevel=GeoLevel.TILE.value, datatype=DataType.TILE.value
            ).order_by("zoom_level", "tile_x", "tile_y")
        )

        total_tiles = len(mvt_tiles)
        self.stdout.write(f"Found {total_tiles} MVT tiles to process")

        if total_tiles == 0:
            self.stdout.write("No tiles found to process")
            return

        updated_count = 0
        skipped_count = 0

        if number_of_threads == 1:
            for mvt_tile in tqdm(mvt_tiles, desc="Processing tiles"):
                try:
                    if self._update_mvt_tile_with_vulnerability(mvt_tile):
                        updated_count += 1
                    else:
                        skipped_count += 1
                except Exception as e:
                    self.stderr.write(f"Error processing tile {mvt_tile.id}: {str(e)}")
                    skipped_count += 1
        else:
            with ThreadPoolExecutor(max_workers=number_of_threads) as executor:
                future_to_tiles = {}

                for mvt_tile in mvt_tiles:
                    future = executor.submit(
                        self._update_mvt_tile_with_vulnerability, mvt_tile
                    )
                    future_to_tiles[future] = mvt_tile

                for future in tqdm(
                    as_completed(future_to_tiles),
                    total=len(future_to_tiles),
                    desc="Processing tiles",
                ):
                    mvt_tile = future_to_tiles[future]
                    try:
                        if future.result():
                            updated_count += 1
                        else:
                            skipped_count += 1
                    except Exception as e:
                        self.stderr.write(
                            f"Error processing tile {mvt_tile.id}: {str(e)}"
                        )
                        skipped_count += 1
                    finally:
                        future_to_tiles.pop(future)
                        gc.collect()

        self.stdout.write(
            self.style.SUCCESS(
                f"Processing complete. Updated: {updated_count}, Skipped: {skipped_count}"
            )
        )

    def _update_mvt_tile_with_vulnerability(self, mvt_tile):
        """Update a single MVT tile with vulnerability data"""
        close_old_connections()
        try:
            decoded_data = self._read_mvt_data(mvt_tile)
            layer_data = self._get_layer_data(decoded_data, mvt_tile)

            if not layer_data:
                return False

            features_updated = self._update_features_with_vulnerability(layer_data)

            if not features_updated:
                return False

            self._save_updated_mvt(mvt_tile, decoded_data)
            return True

        except Exception as e:
            self.stderr.write(f"Failed to process MVT tile {mvt_tile.id}: {str(e)}")
            return False
        finally:
            close_old_connections()

    def _read_mvt_data(self, mvt_tile):
        """Read and decode MVT data from file"""
        mvt_tile.mvt_file.open()
        mvt_data = mvt_tile.mvt_file.read()
        mvt_tile.mvt_file.close()
        return mapbox_vector_tile.decode(mvt_data)

    def _get_layer_data(self, decoded_data, mvt_tile):
        """Get layer data from decoded MVT, return None if not found"""
        layer_name = f"{mvt_tile.geolevel}--{mvt_tile.datatype}"
        if layer_name not in decoded_data:
            self.stderr.write(f"Layer {layer_name} not found in MVT tile {mvt_tile.id}")
            return None
        return decoded_data[layer_name]

    def _update_features_with_vulnerability(self, layer_data):
        """Update features with vulnerability data, return True if any updated"""
        features_updated = False

        for feature in layer_data.get("features", []):
            if self._update_single_feature(feature):
                features_updated = True

        return features_updated

    def _update_single_feature(self, feature):
        """Update a single feature with vulnerability data"""
        properties = feature.get("properties", {})
        tile_id = properties.get("id")

        if not tile_id:
            return False

        if self._has_vulnerability_data(properties):
            return False

        try:
            tile_obj = Tile.objects.select_related("vulnerability_idx").get(id=tile_id)
            return self._add_vulnerability_properties(properties, tile_obj)
        except Tile.DoesNotExist:
            return False

    def _has_vulnerability_data(self, properties):
        """Check if feature already has vulnerability data"""
        return any(key.startswith("vulnerability_") for key in properties.keys())

    def _add_vulnerability_properties(self, properties, tile_obj):
        """Add vulnerability properties to feature properties"""
        if not tile_obj.vulnerability_idx:
            return False

        vulnerability_properties = tile_obj.vulnerability_idx.get_layer_properties()
        for key, value in vulnerability_properties.items():
            if key != "id":
                properties[f"vulnerability_{key}"] = value
        return True

    def _save_updated_mvt(self, mvt_tile, decoded_data):
        """Encode and save updated MVT data"""
        # Transform decoded_data to the format expected by encode()
        layers = []
        for layer_name, layer_data in decoded_data.items():
            layer_with_name = {
                "name": layer_name,
                "features": layer_data.get("features", []),
            }
            if "extent" in layer_data:
                layer_with_name["extent"] = layer_data["extent"]
            if "version" in layer_data:
                layer_with_name["version"] = layer_data["version"]
            layers.append(layer_with_name)

        new_mvt_data = mapbox_vector_tile.encode(layers)
        mvt_tile.mvt_file.save(
            mvt_tile.mvt_file.name, io.BytesIO(new_mvt_data), save=False
        )
        mvt_tile.save()
